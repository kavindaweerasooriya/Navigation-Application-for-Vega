import React, { useRef, useEffect, useState } from 'react';
import mapboxgl from 'mapbox-gl';
import MapboxGeocoder from '@mapbox/mapbox-gl-geocoder';
import '@mapbox/mapbox-gl-geocoder/dist/mapbox-gl-geocoder.css';
import airportIconUrl from '../Assets/car_Icon.png'; 
import './Map.css';

mapboxgl.accessToken =
  'pk.eyJ1IjoidmVnYWlubm92YXRpb25zIiwiYSI6ImNsbTV3c3hwZDA4ZDgzcGxna2IxbDZtNXMifQ.eVpetpE1_nHx3K-LRMPb0g';

const Map = () => {
  const mapContainerRef = useRef(null);
  const [currentLocation, setCurrentLocation] = useState([80.7718, 7.8731]);
  const markerRef = useRef(null);
  // let marker = markerRef.current;
  const [rotationAngle, setRotationAngle] = useState(0);


  let markerIntervalId; 

  useEffect(() => {
    const updateMap = async () => {
      try {
        const response = await fetch('http://localhost:3001/data');
        const data = await response.json();

        if (data && data.data && data.data.latitude && data.data.longitude) {
          setCurrentLocation([data.data.longitude, data.data.latitude]);

          const track = data.data.track || 0;
          setRotationAngle(track);

          console.log('GPS data:', data.data);
        }
      } catch (error) {
        console.error('Error fetching GPS data:', error);
      }
    };

    const gpsDataIntervalId = setInterval(updateMap, 1000);

    return () => {
      clearInterval(gpsDataIntervalId);
    };
  }, []);

  useEffect(() => {
    let marker = markerRef.current;

if (!markerRef.current) {

    const map = new mapboxgl.Map({
      container: mapContainerRef.current,
      style: 'mapbox://styles/vegainnovations/cln9zh9ld03h701pb7jxcdbr1',
      // style: 'mapbox://styles/mapbox/outdoors-v12', 

      zoom: 2,
      center: currentLocation,
      attributionControl: false,
    });

    map.addControl(new mapboxgl.NavigationControl(), 'top-right');
    

    const geocoder = new MapboxGeocoder({
      accessToken: mapboxgl.accessToken,
      mapboxgl: mapboxgl,
    });

    map.addControl(geocoder, 'top-left');

    map.addControl(
      new mapboxgl.GeolocateControl({
        showUserLocation: false
      })
      );

    const markerElement = document.createElement('div');
    markerElement.className = 'custom-marker';
    markerElement.style.backgroundImage = `url(${airportIconUrl})`;
    markerElement.style.width = '8px';
    markerElement.style.height = '8px';

    const marker = new mapboxgl.Marker(markerElement)
      .setLngLat(currentLocation)
      .addTo(map);

    markerRef.current = marker;
    map.on('zoom', () => {
      const currentZoom = map.getZoom();
      const newSize = 5 * currentZoom;

      markerElement.style.width = `${newSize}px`;
      markerElement.style.height = `${newSize}px`;
    });

    window.addEventListener('deviceorientation', (event) => {
      const rotation = event.alpha || 0; // Use alpha (compass heading) if available, or default to 0
      setRotationAngle(rotation);
      marker.setRotation(rotation);
    });
    

  }else{

    markerRef.current.setLngLat(currentLocation);
    markerRef.current.setRotation(rotationAngle);

    
  }
    return () => {
      clearInterval(markerIntervalId);
     
    };
  }, [currentLocation,rotationAngle]);

  return (
    <div>
      <div className="sidebarStyle">
      </div>
      <div className="map-container" ref={mapContainerRef} />
    </div>
  );
};

export default Map;4































import React, { useRef, useEffect, useState } from 'react';
import mapboxgl from 'mapbox-gl';
import MapboxGeocoder from '@mapbox/mapbox-gl-geocoder';
import '@mapbox/mapbox-gl-geocoder/dist/mapbox-gl-geocoder.css';
import airportIconUrl from '../Components/car_Icon.png'; 
import './Map.css';

mapboxgl.accessToken =
  'pk.eyJ1IjoidmVnYWlubm92YXRpb25zIiwiYSI6ImNsbTV3c3hwZDA4ZDgzcGxna2IxbDZtNXMifQ.eVpetpE1_nHx3K-LRMPb0g';

const Map = () => {
  const mapContainerRef = useRef(null);
  const [currentLocation, setCurrentLocation] = useState([80.7718, 7.8731]);
  
  
  const markerRef = useRef(null);
  // let marker = markerRef.current;
  const [rotationAngle, setRotationAngle] = useState(0);
  const [routeSteps, setRouteSteps] = useState([]);
  const directionsLayerId = 'directions';
  const [currentStepIndex, setCurrentStepIndex] = useState(0);
  const serverCoordinatesRef = useRef(null);
  const serverTrackRef = useRef(null);
  const mapRef = useRef(null);
  const [remainingTime, setRemainingTime] = useState(0);
  const [isButtonVisible, setIsButtonVisible] = useState(true);
  const speedRef = useRef(null);

  const [isUpdatingCamera, setIsUpdatingCamera] = useState(false);
  let markerIntervalId; 

  useEffect(() => {
    const updateMap = async () => {
      try {
        const response = await fetch('http://localhost:3001/data');
        const data = await response.json();

        if (data && data.data && data.data.latitude && data.data.longitude) {
          setCurrentLocation([data.data.longitude, data.data.latitude]);
          serverCoordinatesRef.current = [data.data.longitude, data.data.latitude];
          const track = data.data.track || 0;
          serverTrackRef.current = track;
          setRotationAngle(track);
          const speed = data.data.speed;
          speedRef.current = data.data.speed;

          console.log('GPS data:', data.data);
          console.log('speed:', speed);
          console.log('track:', track);
        }
      } catch (error) {
        console.error('Error fetching GPS data:', error);
      }
    };

    const gpsDataIntervalId = setInterval(updateMap, 100);

    return () => {
      clearInterval(gpsDataIntervalId);
    };
  }, []);

  useEffect(() => {
    let marker = markerRef.current;

if (!markerRef.current) {

    const map = new mapboxgl.Map({
      container: mapContainerRef.current,
      style: 'mapbox://styles/vegainnovations/cln9zh9ld03h701pb7jxcdbr1',
      // style: 'mapbox://styles/mapbox/outdoors-v12', 

      zoom: 2,
      center: currentLocation,
      attributionControl: false,
    });

    map.addControl(new mapboxgl.NavigationControl(), 'top-right');
    mapRef.current = map;
    
    const geocoder = new MapboxGeocoder({
      accessToken: mapboxgl.accessToken,
      mapboxgl: mapboxgl,
    });

    geocoder.on('result', (event) => {
      const { geometry } = event.result;
      const coordinates = geometry.coordinates;
    
      calculateAndDisplayRoute(map, serverCoordinatesRef.current, coordinates);
    
      setCurrentLocation(coordinates);
    });



    geocoder.on('clear', () => {
      if (map.getLayer(directionsLayerId)) {
        map.removeLayer(directionsLayerId);
        map.removeSource(directionsLayerId);
      }
      setIsButtonVisible(true);

      setRouteSteps([]);
      setCurrentStepIndex(0);
    });
    
    map.addControl(geocoder, 'top-left');

    map.addControl(
      new mapboxgl.GeolocateControl({
        showUserLocation: false
      })
    );
    
      const markerElement = document.createElement('div');
      markerElement.className = 'custom-marker';
      markerElement.style.backgroundImage = `url(${airportIconUrl})`;
      markerElement.style.width = '8px';
      markerElement.style.height = '8px';
      
      const marker = new mapboxgl.Marker(markerElement)
        .setLngLat(currentLocation)
        .addTo(map);
      
      markerRef.current = marker;
      
      map.on('zoom', () => {
        const currentZoom = map.getZoom();
        const newSize = 5 * currentZoom;
      
        markerElement.style.width = `${newSize}px`;
        markerElement.style.height = `${newSize}px`;
      });

      
      // window.addEventListener('deviceorientation', (event) => {
      //   const rotation = event.alpha || 0; 
      //   const serverTrack = serverTrackRef.current ;
      //   setRotationAngle(rotation);
      //   marker.setRotation(-serverTrack); 
      // });
      // window.addEventListener('deviceorientation', (event) => {
      //   const serverTrack = serverTrackRef.current || 0;
      //   setRotationAngle(serverTrack);
      //   markerRef.current.setRotation(-serverTrack);
      // });


  }else{

    
    if (isUpdatingCamera) {
      // If camera is actively updating, set rotation to 0

      markerRef.current.setLngLat(currentLocation);
      markerRef.current.setRotation(0);
      console.log('handleStartButtonClick rotation:', rotationAngle);
    } else {
      // If camera is not updating, set rotation to rotationAngle

      window.addEventListener('deviceorientation', (event) => {
        const rotation = event.alpha || 0; 
        const serverTrack = serverTrackRef.current ;
        setRotationAngle(rotation);
        marker.setRotation(-serverTrack); 
        console.log('serverTrack:',serverTrack);

      });

      markerRef.current.setLngLat(currentLocation);
      markerRef.current.setRotation(rotationAngle);
      // console.log('rotationAngle:', rotationAngle);
    }

  }
    return () => {
      clearInterval(markerIntervalId);
     
    };
  }, [currentLocation,rotationAngle,isUpdatingCamera]);


  const handleStartButtonClick = () => {
    const map = mapRef.current;
    const marker = markerRef.current;
  
    const updateCamera = () => {
      const currentCoordinates = serverCoordinatesRef.current;
      const currentTrack = serverTrackRef.current;
  
      // Set the marker rotation to always face north (0 degrees)
      // markerRef.current.setRotation(0);
      mapRef.current.setBearing(currentTrack);
      mapRef.current.setCenter(currentCoordinates);
      mapRef.current.setZoom(18);
  
      // map.easeTo({
      //   bearing:currentTrack,
      //   center: currentCoordinates,
      //   zoom: 18,
      // });
      setIsUpdatingCamera(true);
  
      console.log("currentCoordinates updating : " + currentCoordinates, "currentTrack:", currentTrack);
    };
  
    const updateInterval = setInterval(updateCamera, 1);
  
    mapContainerRef.current.addEventListener('click', () => {
      console.log('clicked');
      clearInterval(updateInterval);
      setIsUpdatingCamera(false);
      setCurrentStepIndex((prevIndex) => Math.min(prevIndex + 1, routeSteps.length - 1));
    });
  };
  
  
  
  const calculateAndDisplayRoute = async (map, origin, destination) => {
    try {
      const response = await fetch(
        `https://api.mapbox.com/directions/v5/mapbox/driving/${origin[0]},${origin[1]};${destination[0]},${destination[1]}?geometries=geojson&overview=full&steps=true&access_token=${mapboxgl.accessToken}`
      );
      const data = await response.json();
      console.log(data);
      console.log('origin:',origin[0],origin[1]);
      console.log('destination:',destination[0],destination[1]);
      setIsButtonVisible(false);


      if (data.routes && data.routes.length > 0) {
        const routeGeometry = data.routes[0].geometry;
        const newRouteSteps = data.routes[0].legs.reduce((acc, leg) => acc.concat(leg.steps), []);
        console.log('Route Steps:', newRouteSteps);

        setRouteSteps(newRouteSteps);
        setCurrentStepIndex(0); // Reset step index

        if (map.getLayer(directionsLayerId)) {
          
          map.removeLayer(directionsLayerId);
          map.removeSource(directionsLayerId);
        }

        map.addSource(directionsLayerId, {
          type: 'geojson',
          data: {
            type: 'Feature',
            properties: {},
            geometry: routeGeometry,
          },
        });

        map.addLayer({
          id: directionsLayerId,
          type: 'line',
          source: directionsLayerId,
          layout: {
            'line-join': 'round',
            'line-cap': 'round',
          },
          paint: {
            'line-color': '#3887be',
            'line-width': 5,
            'line-opacity': 0.75,
          },
        });
        setRemainingTime(newRouteSteps[0].duration);

        const intervalId = setInterval(() => {
          setRemainingTime((prevTime) => Math.max(prevTime - 1, 0));
        }, 1000);
        return () => clearInterval(intervalId);
      }
    } catch (error) {
      console.error('Error fetchisng route data:', error);
    }
  };

  return (
    <div>
      <div className="text-paragraph">
        <p>
          {routeSteps.map((step, index) => (
            <span key={index} style={{ display: index === currentStepIndex ? 'block' : 'none' }}>
              {`Step ${index + 1}: ${step.maneuver.instruction}\n`}
            </span>
          ))}
        </p>
      </div>
      <div className="sidebarStyle">
      <button onClick={handleStartButtonClick} style={{ visibility: isButtonVisible ? 'visible' : 'hidden' }}>         //////////////////////////////////////////////////////////////////////
       Start
        </button>
      </div>
      <div className="map-container" ref={mapContainerRef} />
    </div>
  );
};

export default Map;

 // setCurrentStepIndex((prevIndex) => Math.min(prevIndex + 1, routeSteps.length - 1));

 


             const newRemainingTime = data.routes[0].duration;
        const newRemainingDistance = data.routes[0].distance;////////////////////////////////
        console.log("newRemainingTime",newRemainingTime);
        console.log("newRemainingDistance",newRemainingDistance);
        const currentModifier = data.routes[0].modifier || data.routes[0].maneuver.modifier;
        console.log("currentModifier",currentModifier);