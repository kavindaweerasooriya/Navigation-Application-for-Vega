import React, { useRef, useEffect, useState } from 'react';
import mapboxgl from 'mapbox-gl';
import MapboxGeocoder from '@mapbox/mapbox-gl-geocoder';
import '@mapbox/mapbox-gl-geocoder/dist/mapbox-gl-geocoder.css';
import airportIconUrl from '../Components/car_Icon.png'; 
import './Map.css';

mapboxgl.accessToken =
  'pk.eyJ1IjoidmVnYWlubm92YXRpb25zIiwiYSI6ImNsbTV3c3hwZDA4ZDgzcGxna2IxbDZtNXMifQ.eVpetpE1_nHx3K-LRMPb0g';

const Map = () => {
  const mapContainerRef = useRef(null);
  const [currentLocation, setCurrentLocation] = useState([80.7718, 7.8731]);
  const markerRef = useRef(null);
  // let marker = markerRef.current;
  const [rotationAngle, setRotationAngle] = useState(0);
  const [routeSteps, setRouteSteps] = useState([]);
  const directionsLayerId = 'directions';
  const [currentStepIndex, setCurrentStepIndex] = useState(0);
  const serverCoordinatesRef = useRef(null);
  const serverTrackRef = useRef(null);
  const mapRef = useRef(null);
  const [isCameraMoving, setIsCameraMoving] = useState(false);

  let markerIntervalId; 



  const handleStartButtonClick = () => {
    const map = mapRef.current;
    console.log('Start button clicked');
    const marker = markerRef.current;
    console.log('Marker:', marker);
    console.log('Map:', map);
    const currentcordinatesforFunction = serverCoordinatesRef.current;
    console.log('Current coordinates:', currentcordinatesforFunction);
    const currentTrackforFunction = serverTrackRef.current;
    console.log('Current track:', currentTrackforFunction);

    const moveCamera = () => {
      setIsCameraMoving(true);

      if (isCameraMoving) {
        map.flyTo({
          center:  serverCoordinatesRef.current,
          zoom: 18,
          speed: 5,
          bearing: serverTrackRef.current,
        });
        requestAnimationFrame(moveCamera);
      }
    };

    moveCamera();
  };

  const handleMapClick = () => {
    // Stop the continuous camera movement when the map is clicked
    setIsCameraMoving(false);
    console.log('handleMapClick');
  };


  useEffect(() => {
    const map = mapRef.current;

    if (map) {
      // Add a click event listener to the map
      map.on('click', handleMapClick);
    }

    return () => {
      if (map) {
        // Remove the click event listener when the component is unmounted
        map.off('click', handleMapClick);
      }
    };
  }, []);



  useEffect(() => {
    const updateMap = async () => {
      try {
        const response = await fetch('http://localhost:3001/data');
        const data = await response.json();

        if (data && data.data && data.data.latitude && data.data.longitude) {
          setCurrentLocation([data.data.longitude, data.data.latitude]);
          serverCoordinatesRef.current = [data.data.longitude, data.data.latitude];
          const track = data.data.track || 0;
          serverTrackRef.current = track;
          setRotationAngle(track);

          // console.log('GPS data:', data.data);
        }
      } catch (error) {
        console.error('Error fetching GPS data:', error);
      }
    };

    const gpsDataIntervalId = setInterval(updateMap, 1000);

    return () => {
      clearInterval(gpsDataIntervalId);
    };
  }, []);

  useEffect(() => {
    let marker = markerRef.current;

if (!markerRef.current) {

    const map = new mapboxgl.Map({
      container: mapContainerRef.current,
      style: 'mapbox://styles/vegainnovations/cln9zh9ld03h701pb7jxcdbr1',
      // style: 'mapbox://styles/mapbox/outdoors-v12', 

      zoom: 2,
      center: currentLocation,
      attributionControl: false,
    });

    map.addControl(new mapboxgl.NavigationControl(), 'top-right');
    mapRef.current = map;
    

    const geocoder = new MapboxGeocoder({
      accessToken: mapboxgl.accessToken,
      mapboxgl: mapboxgl,
    });


    geocoder.on('result', (event) => {
      const { geometry } = event.result;
      const coordinates = geometry.coordinates;
    
      calculateAndDisplayRoute(map, serverCoordinatesRef.current, coordinates);
    
      setCurrentLocation(coordinates);
    });

    geocoder.on('clear', () => {
      if (map.getLayer(directionsLayerId)) {
        map.removeLayer(directionsLayerId);
        map.removeSource(directionsLayerId);
      }
      setRouteSteps([]);
      setCurrentStepIndex(0);
    });
    

    map.addControl(geocoder, 'top-left');

    map.addControl(
      new mapboxgl.GeolocateControl({
        showUserLocation: false
      })
      );

    const markerElement = document.createElement('div');
    markerElement.className = 'custom-marker';
    markerElement.style.backgroundImage = `url(${airportIconUrl})`;
    markerElement.style.width = '8px';
    markerElement.style.height = '8px';

    const marker = new mapboxgl.Marker(markerElement)
      .setLngLat(currentLocation)
      .addTo(map);

    markerRef.current = marker;
    map.on('zoom', () => {
      const currentZoom = map.getZoom();
      const newSize = 5 * currentZoom;

      markerElement.style.width = `${newSize}px`;
      markerElement.style.height = `${newSize}px`;
    });

    window.addEventListener('deviceorientation', (event) => {
      const rotation = event.alpha || 0; 
      setRotationAngle(rotation);
      marker.setRotation(rotation);
    });
    

  }else{

    markerRef.current.setLngLat(currentLocation);
    markerRef.current.setRotation(rotationAngle);

    
  }
    return () => {
      clearInterval(markerIntervalId);
     
    };
  }, [currentLocation,rotationAngle]);

  const calculateAndDisplayRoute = async (map, origin, destination) => {
    try {
      const response = await fetch(
        `https://api.mapbox.com/directions/v5/mapbox/driving/${origin[0]},${origin[1]};${destination[0]},${destination[1]}?geometries=geojson&overview=full&steps=true&access_token=${mapboxgl.accessToken}`
      );
      const data = await response.json();
      console.log(data);
      console.log('origin:',origin[0],origin[1]);
      console.log('destination:',destination[0],destination[1]);

      if (data.routes && data.routes.length > 0) {
        const routeGeometry = data.routes[0].geometry;
        const newRouteSteps = data.routes[0].legs.reduce((acc, leg) => acc.concat(leg.steps), []);
        console.log('Route Steps:', newRouteSteps);

        setRouteSteps(newRouteSteps);

        if (map.getLayer(directionsLayerId)) {
          map.removeLayer(directionsLayerId);
          map.removeSource(directionsLayerId);
        }

        map.addSource(directionsLayerId, {
          type: 'geojson',
          data: {
            type: 'Feature',
            properties: {},
            geometry: routeGeometry,
          },
        });

        map.addLayer({
          id: directionsLayerId,
          type: 'line',
          source: directionsLayerId,
          layout: {
            'line-join': 'round',
            'line-cap': 'round',
          },
          paint: {
            'line-color': '#3887be',
            'line-width': 5,
            'line-opacity': 0.75,
          },
        });
      }
    } catch (error) {
      console.error('Error fetching route data:', error);
    }
  };

  return (
    <div>
      <div className="text-paragraph">
        <p>
          {routeSteps.map((step, index) => (
            <span key={index} style={{ display: index === currentStepIndex ? 'block' : 'none' }}>
              {`Step ${index + 1}: ${step.maneuver.instruction}\n`}
            </span>
          ))}
        </p>
      </div>
      <div className="sidebarStyle">
      <button onClick={handleStartButtonClick}>
          Start
        </button>
      </div>
      <div className="map-container" ref={mapContainerRef} />
    </div>
  );
};

export default Map;

 // setCurrentStepIndex((prevIndex) => Math.min(prevIndex + 1, routeSteps.length - 1));





















   const handleStartButtonClick = () => {
    const map = mapRef.current;
    const marker = markerRef.current;
  
    const updateCamera = () => {
      const currentCoordinates = serverCoordinatesRef.current;
      const currentTrack = serverTrackRef.current;
  
      // Set the marker rotation to face north
      markerRef.current.setRotation(0);
  
      // Set the map's center and zoom without animation
      map.jumpTo({
        center: currentCoordinates,
        zoom: 18,
      });
  
      // Set the map's bearing to match the heading of the marker
      map.setBearing(currentTrack);
  
      console.log("currentCoordinates:", currentCoordinates, "currentTrack:", currentTrack);
    };
  
    const updateInterval = setInterval(updateCamera, 1);
  
    mapContainerRef.current.addEventListener('click', () => {
      console.log('clicked');
      clearInterval(updateInterval);
    });
  };